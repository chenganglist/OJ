#include <stdio.h>

// KMP算法只是判断A字符串是否包含B字符串的算法，算法复杂度为o(n)
// 如果求最大公共子字符串，需要嵌套子字符串查找，复杂度为o(n^2)
// 动态规划：
// 移动位数 = 已匹配的字符数 - 对应的部分匹配值
// 学习快速排序，红黑树，字典树，B树、后缀树，包括KMP算法
// "部分匹配"的实质是，有时候，字符串头部和尾部会有重复。
// 比如，"ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是2（"AB"的长度）。
// 搜索词移动的时候，第一个"AB"向后移动4位（字符串长度-部分匹配值），
// 就可以来到第二个"AB"的位置。


// 一：反复搜索suanfa
// 二：KMP算法--核心匹配字符串对本字符串的匹配，next数组移位
int main(int argc,char* argv[])
{

    return 0;
}